name: Deploy to EC2 via SSM (No SSH)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options: [staging, production]
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'latest'

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: water-quality-ml

jobs:
  deploy-via-ssm:
    name: Deploy to EC2 via AWS Systems Manager
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set deployment variables
        id: vars
        run: |
          env="${{ github.event.inputs.environment }}"
          tag="${{ github.event.inputs.image_tag }}"

          if [ "$env" = "production" ]; then
            echo "instance_id=${{ secrets.PROD_EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/mlops-production" >> $GITHUB_OUTPUT
            echo "app_port=8000" >> $GITHUB_OUTPUT
          else
            echo "instance_id=${{ secrets.STAGING_EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/mlops-staging" >> $GITHUB_OUTPUT
            echo "app_port=8000" >> $GITHUB_OUTPUT
          fi

          # ECR registry must be provided via secrets (ECR_REGISTRY or ECR_URI)
          if [ -n "${{ secrets.ECR_REGISTRY }}" ]; then
            echo "image_uri=${{ secrets.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${tag}" >> $GITHUB_OUTPUT
          else
            echo "image_uri=${{ secrets.ECR_URI }}/${{ env.ECR_REPOSITORY }}:${tag}" >> $GITHUB_OUTPUT
          fi
          
      - name: Resolve EC2 instance ID
        id: resolve-instance
        run: |
          set -euo pipefail
          CANDIDATE_ID="${{ steps.vars.outputs.instance_id }}"

          echo "Debug: candidate instance id from secrets: '$CANDIDATE_ID'"

          RESOLVED_ID=""

          # Validate provided instance id format (i-123...)
          if [[ -n "$CANDIDATE_ID" && "$CANDIDATE_ID" =~ ^i-([0-9a-f]{8}|[0-9a-f]{17})$ ]]; then
            RESOLVED_ID="$CANDIDATE_ID"
            echo "Using provided instance id: $RESOLVED_ID"
          else
            echo "Provided instance_id empty/invalid; attempting to resolve by tag..."
            if [ "${{ github.event.inputs.environment }}" = "production" ]; then
              TAG_NAME="${{ secrets.PROD_EC2_TAG_NAME }}"
              [ -z "$TAG_NAME" ] && TAG_NAME="mlops-production"
            else
              TAG_NAME="${{ secrets.STAGING_EC2_TAG_NAME }}"
              [ -z "$TAG_NAME" ] && TAG_NAME="mlops-staging"
            fi

            echo "Looking for running instance with tag Name=$TAG_NAME in region $AWS_REGION"

            # Get the first running instance id for the tag (if multiple, pick first)
            RESOLVED_ID=$(aws ec2 describe-instances \
              --region "$AWS_REGION" \
              --filters "Name=tag:Name,Values=$TAG_NAME" "Name=instance-state-name,Values=running" \
              --query 'Reservations[].Instances[].InstanceId' \
              --output text | awk '{print $1}' || true)

            if [ -n "$RESOLVED_ID" ]; then
              echo "Resolved by tag: $RESOLVED_ID"
            else
              echo "No running instance found with Name=$TAG_NAME"
            fi
          fi

          if [ -z "$RESOLVED_ID" ]; then
            echo "ERROR: Could not resolve a valid EC2 instance ID."
            echo "- Provide a valid instance ID via secrets STAGING_EC2_INSTANCE_ID/PROD_EC2_INSTANCE_ID"
            echo "- Or tag your instance Name=mlops-staging (or mlops-production) or set STAGING_EC2_TAG_NAME/PROD_EC2_TAG_NAME"
            exit 1
          fi

          echo "resolved_instance_id=$RESOLVED_ID" >> $GITHUB_OUTPUT

      - name: Send deployment command via SSM
        id: send-ssm
        run: |
          set -euo pipefail
          INSTANCE_ID="${{ steps.resolve-instance.outputs.resolved_instance_id }}"
          IMAGE_URI="${{ steps.vars.outputs.image_uri }}"
          APP_DIR="${{ steps.vars.outputs.app_dir }}"
          APP_PORT="${{ steps.vars.outputs.app_port }}"
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          ECR_REGISTRY="${{ secrets.ECR_REGISTRY }}"
          AWS_REGION="${{ env.AWS_REGION }}"

          echo "Sending deployment command to instance: $INSTANCE_ID"
          echo "Image: $IMAGE_URI"
          echo "Environment: $ENVIRONMENT"

          # Define the script as a shell variable.
          # Using single quotes (') for the outer wrapper prevents premature expansion.
          # Variables like '$USER' are escaped ('\$USER') to be expanded on the remote EC2 instance, not in GitHub Actions.
          read -r -d '' SCRIPT_CONTENT << 'EOF'
          set -e
          echo "===== MLOps Deployment Script (Idempotent) ====="
          echo "Environment: ${ENVIRONMENT}"
          echo "Image: ${IMAGE_URI}"
          echo ""

          # Step 1: Install Docker (if missing)
          echo "[1/6] Checking Docker installation..."
          if ! command -v docker &> /dev/null; then
            echo "Docker not found. Installing..."
            sudo apt-get update -qq
            sudo apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common gnupg
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update -qq
            sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io
            sudo systemctl enable docker --now
            sudo usermod -aG docker \$USER || true
            echo "✓ Docker installed"
          else
            echo "✓ Docker already installed: $(docker --version)"
          fi

          sudo systemctl is-active --quiet docker || sudo systemctl start docker
          echo ""

          # Step 2: Ensure AWS CLI is present
          echo "[2/6] Checking AWS CLI..."
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found. Installing..."
            curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o /tmp/awscliv2.zip
            sudo apt-get install -y -qq unzip
            unzip -q /tmp/awscliv2.zip -d /tmp
            sudo /tmp/aws/install --update
            rm -rf /tmp/awscliv2.zip /tmp/aws
            echo "✓ AWS CLI installed"
          else
            echo "✓ AWS CLI already installed: $(aws --version)"
          fi
          echo ""

          # Step 3: Prepare application directory
          echo "[3/6] Preparing application directory..."
          sudo mkdir -p "${APP_DIR}"
          sudo chown \$USER:\$USER "${APP_DIR}"
          cd "${APP_DIR}"
          echo "✓ App directory ready: ${APP_DIR}"
          echo ""

          # Step 4: Pull image from ECR
          echo "[4/6] Pulling image from ECR..."
          aws ecr get-login-password --region "${AWS_REGION}" | sudo docker login --username AWS --password-stdin "${ECR_REGISTRY}"
          sudo docker pull "${IMAGE_URI}"
          echo "✓ Image pulled successfully"
          echo ""

          # Step 5: Deploy container
          echo "[5/6] Deploying container..."
          sudo docker stop water-quality-app 2>/dev/null || echo "  (no existing container to stop)"
          sudo docker rm water-quality-app 2>/dev/null || echo "  (no existing container to remove)"
          sudo docker run -d \
            --name water-quality-app \
            --restart unless-stopped \
            -p "${APP_PORT}":8000 \
            -e AWS_REGION="${AWS_REGION}" \
            -e ENVIRONMENT="${ENVIRONMENT}" \
            "${IMAGE_URI}"
          echo "✓ Container started"
          echo ""

          # Step 6: Health check
          echo "[6/6] Running health check..."
          for i in {1..30}; do
            if curl -sf http://localhost:"${APP_PORT}"/ >/dev/null 2>&1; then
              echo "✓ Health check passed! Application is responding."
              curl -s http://localhost:"${APP_PORT}"/ | head -n 3
              break
            fi
            if [ \$i -eq 30 ]; then
              echo "✗ Health check failed after 30 attempts"
              echo "Container logs:"
              sudo docker logs water-quality-app --tail 200 || true
              exit 1
            fi
            echo "  Waiting for app to start (attempt \$i/30)..."
            sleep 2
          done
          echo ""

          # Summary
          echo "===== Deployment Complete ====="
          echo "Container: water-quality-app"
          echo "Status: $(sudo docker inspect -f '{{.State.Status}}' water-quality-app)"
          echo "Port: ${APP_PORT}"
          echo "Image: ${IMAGE_URI}"
          echo "Started: $(sudo docker inspect -f '{{.State.StartedAt}}' water-quality-app)"
          echo "==============================="
          EOF

          # Build the AWS CLI command using a JSON file for robust parameter passing
          SSM_PARAMS_JSON=$(mktemp)
          cat > "$SSM_PARAMS_JSON" <<JSON
          {
            "commands": ["export APP_DIR='${APP_DIR}' IMAGE_URI='${IMAGE_URI}' APP_PORT='${APP_PORT}' ENVIRONMENT='${ENVIRONMENT}' ECR_REGISTRY='${ECR_REGISTRY}' AWS_REGION='${AWS_REGION}'; ${SCRIPT_CONTENT}"]
          }
          JSON

          SSM_CMD=(
            aws ssm send-command
            --instance-ids "$INSTANCE_ID"
            --document-name "AWS-RunShellScript"
            --comment "Deploy $IMAGE_URI to $ENVIRONMENT"
            --parameters "file://$SSM_PARAMS_JSON"
            --cloud-watch-output-config '{"CloudWatchLogGroupName":"/aws/ssm/mlops-deploy","CloudWatchOutputEnabled":true}'
          )

          if [ -n "${{ secrets.SSM_OUTPUT_BUCKET }}" ]; then
            SSM_CMD+=(
              --output-s3-bucket-name "${{ secrets.SSM_OUTPUT_BUCKET }}"
              --output-s3-key-prefix "ssm-logs/$ENVIRONMENT"
            )
          fi

          SSM_CMD+=(
            --query "Command.CommandId"
            --output text
          )
          
          # Execute the command and capture the command ID
          COMMAND_ID=$("${SSM_CMD[@]}")

          echo "Command ID: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_ENV
          
          # Cleanup
          rm -f "$SSM_PARAMS_JSON"

      - name: Wait for deployment to complete
        run: |
          set -euo pipefail
          INSTANCE_ID="${{ steps.resolve-instance.outputs.resolved_instance_id }}"
          CMD_ID="${{ env.command_id }}"
          echo "Waiting for SSM command $CMD_ID on instance $INSTANCE_ID"
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text || echo "Unknown")
            echo "Attempt $i: Status = $STATUS"
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text || true
              exit 0
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "❌ Deployment failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text || true
              exit 1
            fi
            sleep 10
          done
          echo "⏱️ Deployment timed out after 10 minutes"
          exit 1

      - name: Health check (external)
        run: |
          sleep 15
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            ENDPOINT="${{ secrets.PROD_URL }}"
          else
            ENDPOINT="${{ secrets.STAGING_URL }}"
          fi
          echo "Testing endpoint: $ENDPOINT"
          if curl -sf "$ENDPOINT"; then
            echo "External endpoint OK"
          else
            echo "⚠️  External health check failed (check security groups / ALB / public IP)"
          fi
          # Try prediction endpoint (non-fatal)
          curl -sf -X POST "$ENDPOINT/predict" -H "Content-Type: application/json" -d '{"features":[7.0,200.0,20000.0,7.5,400.0,200.0,15.0,20.0,350.0]}' || echo "⚠️ Prediction endpoint test failed"

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.vars.outputs.image_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance ID**: ${{ steps.resolve-instance.outputs.resolved_instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SSM Command ID**: ${{ env.command_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View logs in CloudWatch: /aws/ssm/mlops-deploy" >> $GITHUB_STEP_SUMMARY
